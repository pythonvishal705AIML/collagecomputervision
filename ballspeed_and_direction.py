# -*- coding: utf-8 -*-
"""ballspeed and direction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rs5dSV8Q3-yxZk8D8ldmXmeEU0o_0nxf
"""

import cv2
import numpy as np
import math
from collections import deque
import time

video_filename = "/content/drive/MyDrive/comvision/WhatsApp Video 2024-04-25 at 14.18.41_8ba251ab.mp4"

cap = cv2.VideoCapture(video_filename)


lower_red = np.array([0, 179, 100])                              #   because of red ball
upper_red = np.array([38, 255, 255])

width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = int(cap.get(cv2.CAP_PROP_FPS))

output_path = "/content/drive/MyDrive/comvision/T2346788678.mp4"
out = cv2.VideoWriter(output_path, cv2.VideoWriter_fourcc(*'MP4V'), fps, (width, height))


ball_path = deque(maxlen=10)                                  # List to store centroids of the ball for the last 10 frames
prev_ball_centroid = None
prev_predicted_centroid = None
prev_time = None

while True:
    ret, frame = cap.read()                                                             #frame read

    if not ret:
        print("Video processing complete")
        break

    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)                                           #frame to HSV color

    mask = cv2.inRange(hsv, lower_red, upper_red)                                          #mask red

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)       #finding boundry of red colour


    if len(contours) > 0:
        largest_contour = max(contours, key=cv2.contourArea)                                   #finding large boundary

        ((x, y), radius) = cv2.minEnclosingCircle(largest_contour)                              #centre of contour
        ball_centroid = (int(x), int(y))

        ball_path.appendleft(ball_centroid)

        radius = int(radius)                                                                  #cal radius

        cv2.circle(frame, ball_centroid, radius, (0, 255, 0), 2)                               #drawing circle


        if prev_ball_centroid is not None and prev_predicted_centroid is not None:             #next position based on previous
            dx = ball_centroid[0] - prev_ball_centroid[0]
            dy = ball_centroid[1] - prev_ball_centroid[1]
            next_predicted_centroid = (ball_centroid[0] + dx, ball_centroid[1] + dy)

            cv2.line(frame, prev_predicted_centroid, next_predicted_centroid, (255, 0, 0), -1)           #try to find directary and line




# Calculate speed (pixels per second)

            if prev_time is not None:
                current_time = time.time()                                      #set time
                time_elapsed = current_time - prev_time
                displacement = math.sqrt(dx ** 2 + dy ** 2)                     #eclidian dist
                speed = displacement / time_elapsed
                cv2.putText(frame, "Speed: {:.2f} pixels/sec".format(speed), (10, 90),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)
                prev_time = current_time


        prev_ball_centroid = ball_centroid
        prev_predicted_centroid = next_predicted_centroid if 'next_predicted_centroid' in locals() else ball_centroid
        prev_time = time.time()

    out.write(frame)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

cap.release()
out.release()
cv2.destroyAllWindows()

print("Saving processed video...")
print("Processed video saved at:", output_path)











































import cv2 as cv
vidcap = cv.VideoCapture(1)
while True:
  ret,frame = vidcap.read()
  cv.imshow('frame',frame)
  if cv.waitKey(1) & 0xFF == ord('q'):
    break
vidcap.release()
cv.destroyAllWindows()













































face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Initialize variables
prev_pts = None
deviation_point = None
ground_hit_point = None
batsman_point = None

# Loop through each frame of the video
while True:
    ret, frame = cap.read()

    if not ret:
        print("Video processing complete")
        break
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # Thresholding to isolate ball color
    mask = cv2.inRange(hsv, lower_ball_color, upper_ball_color)
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if len(contours) > 0:
        bottom_contour = max(contours, key=lambda c: cv2.boundingRect(c)[1] + cv2.boundingRect(c)[3])
        x, y, w, h = cv2.boundingRect(bottom_contour)
        ground_hit_point = (x + w // 2, y + h)
        cv2.circle(frame, ground_hit_point, 5, (0, 255, 0), -1)
        print("Ground hit point coordinates (x1, y1):", ground_hit_point)

    # Convert frame to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(30, 30))

    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)
        batsman_point = (x + w // 2, y + h // 2)

    if prev_pts is not None:
        pts, status, _ = cv2.calcOpticalFlowPyrLK(prev_gray, gray, prev_pts, None)
        good_new = pts[status == 1]
        good_old = prev_pts[status == 1]
        displacements = good_new - good_old

        deviation_point = np.mean(displacements, axis=0)

        # Draw circles at the deviation point for visualization
        deviation_point = tuple(map(int, deviation_point))
        cv2.circle(frame, deviation_point, 5, (0, 255, 255), -1)

    # Update previous frame and points
    prev_gray = gray.copy()
    prev_pts = cv2.goodFeaturesToTrack(gray, maxCorners=100, qualityLevel=0.3, minDistance=7, blockSize=7)


    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()

# Output the ground hit point coordinates
if ground_hit_point is None:
    print("No ground hit point detected")
else:
    print("Ground hit point coordinates (x1, y1):", ground_hit_point)

# Output the batsman point coordinates
if batsman_point is None:
    print("Batsman point not detected")
else:
    print("Batsman point coordinates (x2, y2):", batsman_point)

# Output the deviation point coordinates
if deviation_point is None:
    print("No deviation point detected")
else:
    print("Deviation point coordinates (x, y):", deviation_point)

ground_hit_point = (917, 506)
batsman_point = (680, 283)
deviation_point = (0, 0)

# Calculate the vectors from the ground hit point to the batsman point and deviation point
vector_bp = (batsman_point[0] - ground_hit_point[0], batsman_point[1] - ground_hit_point[1])
vector_dp = (deviation_point[0] - ground_hit_point[0], deviation_point[1] - ground_hit_point[1])

dot_product = vector_bp[0] * vector_dp[0] + vector_bp[1] * vector_dp[1]

magnitude_bp = math.sqrt(vector_bp[0] ** 2 + vector_bp[1] ** 2)
magnitude_dp = math.sqrt(vector_dp[0] ** 2 + vector_dp[1] ** 2)

# Calculate the cosine of the deviation angle using the dot product and magnitudes
cos_deviation_angle = dot_product / (magnitude_bp * magnitude_dp)
deviation_angle_degrees = math.degrees(math.acos(cos_deviation_angle))

print("Deviation angle:", deviation_angle_degrees)

